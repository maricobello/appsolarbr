# -*- coding: utf-8 -*-
"""appsolarbr1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oJzKDi7oakflTfnUDf9Sphl7eXqfjHwM
"""

import streamlit as st
import geocoder
import requests
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from io import BytesIO
from PIL import Image
import rasterio
from rasterio.io import MemoryFile
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import matplotlib.pyplot as plt
import math

# BING_KEY = st.secrets.BING_KEY
GOOGLE_SOLAR_KEY = st.secrets.GOOGLE_SOLAR_KEY
SOLAR_INSIGHTS_ENDPOINT = 'https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude={}&location.longitude={}&requiredQuality=LOW&key={}'

# streamlit_app.py

import streamlit as st

def check_password():
    """Retorna `True` se o usu√°rio inserir a senha correta."""

    def password_entered():
        """Verifica se a senha inserida pelo usu√°rio est√° correta."""
        if st.session_state["password"] == st.secrets["password"]:
            st.session_state["password_correct"] = True
            del st.session_state["password"]  # n√£o armazene a senha
        else:
            st.session_state["password_correct"] = False

    if "password_correct" not in st.session_state:
        # Primeira execu√ß√£o, exibir entrada para a senha.
        st.text_input(
            "Senha", type="password", on_change=password_entered, key="password"
        )
        return False
    elif not st.session_state["password_correct"]:
        # Senha incorreta, exibir entrada + erro.
        st.text_input(
            "Senha", type="password", on_change=password_entered, key="password"
        )
        st.error("üòï Senha incorreta")
        return False
    else:
        # Senha correta.
        return True

@st.cache_data
def get_lat_lng_bing(address):
    g = geocoder.bing(address, key=BING_KEY)
    results = g.json
    return (results['lat'], results['lng'])

def get_lat_lng(address):
    """
    Obt√©m a latitude e longitude de um endere√ßo usando a API de Geocodifica√ß√£o do Google.

    Par√¢metros:
    - address: O endere√ßo a ser geocodificado.
    - api_key: Sua chave da API do Google.

    Retorna:
    - Uma tupla contendo a latitude e a longitude.
    """
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={address}&key={GOOGLE_SOLAR_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['status'] == 'OK':
            latitude = data['results'][0]['geometry']['location']['lat']
            longitude = data['results'][0]['geometry']['location']['lng']
            return latitude, longitude
        else:
            print(f"Erro: {data['status']}")
            return None, None
    else:
        print(f"Falha ao obter os dados: {response.status_code}")
        return None, None

@st.cache_data
def get_solar_insights(lat, lng):
    response = requests.get(SOLAR_INSIGHTS_ENDPOINT.format(lat, lng, GOOGLE_SOLAR_KEY))
    return response.json()

@st.cache_data
def get_google_maps_image(lat, lon, zoom=19, size="600x600", maptype="sat√©lite", api_key=GOOGLE_SOLAR_KEY):
    base_url = "https://maps.googleapis.com/maps/api/staticmap?"
    params = {
        "center": f"{lat},{lon}",
        "zoom": zoom,
        "size": size,
        "maptype": maptype,
        "key": api_key
    }
    response = requests.get(base_url, params=params)
    response.raise_for_status()
    image = Image.open(BytesIO(response.content))
    return image

# Fun√ß√£o para exibir uma banda espec√≠fica de um arquivo GeoTIFF a partir de uma URL com anota√ß√£o
def display_monthly_flux(data_layers, api_key):
    # Para o fluxo mensal, voc√™ precisa lidar com v√°rias bandas, pois ele cont√©m dados para cada m√™s
    monthly_flux_url_with_key = f"{data_layers['monthlyFluxUrl']}&key={api_key}"
    response = requests.get(monthly_flux_url_with_key)
    if response.status_code == 200:
        with MemoryFile(response.content) as memfile:
            with memfile.open() as dataset:
                for i in range(1, dataset.count + 1):  # Percorrer cada banda
                    fig, ax = plt.subplots()  # Criar uma nova figura e eixos do matplotlib
                    band = dataset.read(i)
                    im = ax.imshow(band) #cmap='viridis')  # Armazenar o objeto mape√°vel em im
                    #plt.colorbar(im, ax=ax)  # Passar o objeto mape√°vel para o colorbar
                    ax.set_title(f"Fluxo Solar Mensal - M√™s {i}")
                    st.pyplot(fig)  # Passar a figura do matplotlib para st.pyplot()
                    plt.close(fig)  # Fechar a figura
    else:
        print(f"Falha ao buscar os dados. C√≥digo de status: {response.status_code}")
        # Fun√ß√£o para exibir todas as bandas de um arquivo GeoTIFF a partir de uma URL com anota√ß√£o
def display_all_geotiff_bands(url, api_key, title):
    url_with_key = f"{url}&key={api_key}"
    response = requests.get(url_with_key)
    if response.status_code == 200:
        with MemoryFile(response.content) as memfile:
            with memfile.open() as dataset:
                fig, ax = plt.subplots()  # Criar uma nova figura e eixos do matplotlib
                if dataset.count > 1:
                    band = dataset.read([1, 2, 3])
                    band = np.transpose(band, (1, 2, 0))
                else:
                    band = dataset.read(1)
                    band = band.squeeze()

                im = ax.imshow(band)  # Armazenar o objeto mape√°vel em im, cmap='viridis' se dataset.count == 1 else None
                #plt.colorbar(im, ax=ax)  # Passar o objeto mape√°vel para o colorbar
                ax.set_title(title)
                st.pyplot(fig)  # Passar a figura do matplotlib para st.pyplot()
                plt.close(fig)  # Fechar a figura

# Fun√ß√£o para obter camadas de dados
@st.cache_data
def get_data_layers(lat, lon, radius=50, view="FULL_LAYERS", quality="LOW", pixel_size=0.5):
    url = f"https://solar.googleapis.com/v1/dataLayers:get"
    params = {
        "location.latitude": lat,
        "location.longitude": lon,
        "radiusMeters": radius,
        "view": view,
        "requiredQuality": quality,
        "pixelSizeMeters": pixel_size,
        "key": GOOGLE_SOLAR_KEY  # Substitua pela sua chave real da API Solar do Google
    }
    response = requests.get(url, params=params)
    return response.json()

# Visualiza√ß√£o 2D
def plot_roof_segments(roof_segments):
    # Criar figura e eixos
    fig, ax = plt.subplots()

    # Plotar cada segmento
    for segment in roof_segments:
        sw = segment['boundingBox']['sw']
        ne = segment['boundingBox']['ne']
        center = segment['center']

        # Calcular a largura e a altura do ret√¢ngulo
        width = ne['longitude'] - sw['longitude']
        height = ne['latitude'] - sw['latitude']

        # Criar um ret√¢ngulo representando o segmento do telhado
        rect = patches.Rectangle((sw['longitude'], sw['latitude']), width, height,
                                 linewidth=1, edgecolor='r', facecolor='none')
        ax.add_patch(rect)

        # Usar azimute para representar a orienta√ß√£o do segmento do telhado
        azimuth = segment['azimuthDegrees']
        pitch = segment['pitchDegrees']

        # Calcular o ponto final para a linha que indica a orienta√ß√£o
        # Aqui, estamos usando um m√©todo simples para calcular o ponto final; voc√™ pode precisar ajustar isso
        end_lon = center['longitude'] + np.cos(np.radians(azimuth)) * width * 0.5
        end_lat = center['latitude'] + np.sin(np.radians(azimuth)) * height * 0.5

        # Desenhar uma linha que indica a orienta√ß√£o do segmento do telhado
        ax.plot([center['longitude'], end_lon], [center['latitude'], end_lat], 'k-')

        # Opcionalmente, anotar o pitch do segmento do telhado
        ax.text(center['longitude'], center['latitude'], f"{pitch:.1f}¬∞",
                fontsize=9, ha='center', va='center')

    # Definir r√≥tulos e t√≠tulo
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title('Segmentos do Telhado com Orienta√ß√£o e Inclina√ß√£o')

    # Ajustar limites do gr√°fico
    ax.set_xlim(min([seg['boundingBox']['sw']['longitude'] for seg in roof_segments]),
                max([seg['boundingBox']['ne']['longitude'] for seg in roof_segments]))
    ax.set_ylim(min([seg['boundingBox']['sw']['latitude'] for seg in roof_segments]),
                max([seg['boundingBox']['ne']['latitude'] for seg in roof_segments]))

    # Mostrar o gr√°fico
    st.pyplot(fig)

# Visualiza√ß√£o 3D
def plot_3d_roof_segments(roof_segments):
    if not roof_segments:
        st.write("Nenhum dado de segmentos de telhado dispon√≠vel.")
        return

    fig, ax = plt.subplots(subplot_kw={'projection': '3d'})

    for segment in roof_segments:
        sw = segment['boundingBox']['sw']
        ne = segment['boundingBox']['ne']
        height = segment['planeHeightAtCenterMeters']
        pitch = math.radians(segment['pitchDegrees'])
        azimuth = math.radians(segment['azimuthDegrees'])

        # Depura√ß√£o: Imprimir inclina√ß√£o e azimute
        #st.write(f"Inclina√ß√£o: {pitch} radianos, Azimute: {azimuth} radianos")

        # Calcular a diferen√ßa de altura com base na inclina√ß√£o e no azimute
        delta_height = np.tan(pitch) * np.sqrt((ne['longitude'] - sw['longitude'])**2 + (ne['latitude'] - sw['latitude'])**2)
        delta_x = delta_height * np.sin(azimuth)
        delta_y = delta_height * np.cos(azimuth)

        vertices = np.array([[sw['longitude'], sw['latitude'], height],
                             [ne['longitude'], sw['latitude'], height + delta_x],
                             [ne['longitude'], ne['latitude'], height + np.sqrt(delta_x**2 + delta_y**2)],
                             [sw['longitude'], ne['latitude'], height + delta_y]])

        # Depura√ß√£o: Imprimir v√©rtices
        #st.write(vertices)

        # Criar faces
        faces = [[vertices[j] for j in [0, 1, 2, 3]]]

        poly = Poly3DCollection(faces, alpha=0.5, edgecolors='k', linewidths=1)
        ax.add_collection3d(poly)

    # Definir limites dos eixos e r√≥tulos
    ax.set_xlim(min(segment['boundingBox']['sw']['longitude'] for segment in roof_segments),
                max(segment['boundingBox']['ne']['longitude'] for segment in roof_segments))
    ax.set_ylim(min(segment['boundingBox']['sw']['latitude'] for segment in roof_segments),
                max(segment['boundingBox']['ne']['latitude'] for segment in roof_segments))
    ax.set_zlim(0, max(segment['planeHeightAtCenterMeters'] for segment in roof_segments) + 20)  # Limites z ajustados

    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_zlabel('Altura')
    ax.set_title('Visualiza√ß√£o 3D de Segmentos de Telhado')

    # Mostrar gr√°fico no Streamlit
    st.pyplot(fig)

# Calculadora
def get_yearly_energy(data, panels_count):
    for config in data['solarPotential']['solarPanelConfigs']:
        if config['panelsCount'] == panels_count:
            return config['yearlyEnergyDcKwh']
    return None

def solar_calculator(data):
    st.subheader('Calculadora de Economia Solar')

    # Extrair n√∫mero m√≠nimo e m√°ximo de pain√©is dos resultados da API
    min_panels = data['solarPotential']['solarPanelConfigs'][0]['panelsCount']
    max_panels = data['solarPotential']['maxArrayPanelsCount']

    # Entradas com valores padr√£o
    # if 'num_panels' not in st.session_state:
    #     st.session_state.num_panels = max_panels

    if 'kw_per_panel' not in st.session_state:
        st.session_state.kw_per_panel = 0.3

    if 'electricity_price' not in st.session_state:
        st.session_state.electricity_price = 0.12

    if 'panel_area_m2' not in st.session_state:
        st.session_state.panel_area_m2 = 1.5

    # st.session_state.num_panels = st.number_input('N√∫mero de Pain√©is Solares', value=st.session_state.num_panels)
    # st.session_state.kw_per_panel = st.number_input('kW por Painel Solar', value=st.session_state.kw_per_panel)
    # st.session_state.electricity_price = st.number_input('Pre√ßo da Eletricidade (por kWh)', value=st.session_state.electricity_price)
    # st.session_state.panel_area_m2 = st.number_input('√Årea por Painel Solar (em m^2)', value=st.session_state.panel_area_m2)

    # C√°lculos
    # Entradas
    panels = st.slider('N√∫mero de Pain√©is Solares', min_value=min_panels, max_value=max_panels, value=max_panels)
    user_wattage = st.number_input('Pot√™ncia do Painel Solar', value=430.0, step=10.0)  # O usu√°rio pode ajustar a pot√™ncia
    electricity_price = st.number_input('Pre√ßo da Eletricidade (R$/kWh)', value=0.81, step=0.01)

    # Calcular
    energia_api = get_yearly_energy(data, panels)
    energia_ajustada = energia_api * (user_wattage / 250.0)  # Ajustar com base na pot√™ncia especificada pelo usu√°rio
    economia_anual = energia_ajustada * electricity_price

    # Exibir
    st.write(f"Gera√ß√£o Anual de Energia Estimada: {energia_ajustada:.2f} kWh")
    st.write(f"Economia Anual Estimada: ‚Ç¨{economia_anual:.2f}")

def main():
    st.title('Insights de Pain√©is Solares')

    address = st.text_input("Digite seu endere√ßo:")

    # Verifique se o endere√ßo est√° na session_state
    if 'address' not in st.session_state:
        st.session_state.address = ''

    # Verifique se os dados j√° est√£o na session_state e se o endere√ßo foi alterado
    if 'data' not in st.session_state or st.session_state.address != address:
        if st.button('Obter Insights'):
            lat, lng = get_lat_lng(address)
            data = get_solar_insights(lat, lng)
            print(data)
            st.session_state.data = data
            st.session_state.address = address

    # Se os dados estiverem na session_state, exiba-os
    if 'data' in st.session_state:
        data = st.session_state.data
        lat, lng = get_lat_lng(st.session_state.address)

        # Exibir a imagem da casa
        imagem = get_google_maps_image(lat, lng)
        if 'imageryDate' in data:
            st.image(imagem, caption=f"Imagem da Casa de {data['imageryDate']['year']}-{data['imageryDate']['month']}-{data['imageryDate']['day']}", use_column_width=True)
        else:
            st.image(imagem, caption="Imagem da Casa", use_column_width=True)

        # Exibir dados solares
        st.subheader('Potencial Solar')
        # Adicione uma observa√ß√£o usando st.markdown
        st.markdown("_Aviso: Com base nos dados da API Solar do Google (altura do painel - 1,65m, largura do painel - 0,99m, 250 Watts)._")
        st.markdown(f"_Coordenadas do endere√ßo: {lat} {lng}_")
        st.write(f"N√∫mero M√°ximo de Pain√©is na Matriz: {data['solarPotential']['maxArrayPanelsCount']}")
        st.write(f"√Årea M√°xima de Pain√©is Solares (m^2): {data['solarPotential']['maxArrayAreaMeters2']}")
        st.write(f"√Årea Total do Telhado (m^2): {data['solarPotential']['wholeRoofStats']['areaMeters2']}")
        st.write(f"Segmentos de Telhado: {len(data['solarPotential']['roofSegmentStats'])}")
        st.write(f"M√°ximo de Horas de Sol Anuais: {data['solarPotential']['maxSunshineHoursPerYear']}")

        if 'roofSegmentStats' in data['solarPotential']:
            st.subheader('Visualiza√ß√£o 2D de Segmentos de Telhado')
            plot_roof_segments(data['solarPotential']['roofSegmentStats'])

            st.subheader('Visualiza√ß√£o 3D de Segmentos de Telhado')
            segmentos_telhado = data['solarPotential']['roofSegmentStats']
            plot_3d_roof_segments(segmentos_telhado)

        # Calculadora
        solar_calculator(data)

        # Expansor com JSON completo
        with st.expander("Clique para expandir a resposta completa da API solar", expanded=False):
            st.write(data)

        if st.button('Obter Camadas de Dados'):
            # Obtenha as camadas de dados
            camadas_dados = get_data_layers(lat, lng)  # Certifique-se de implementar esta fun√ß√£o para chamar a segunda API e obter as camadas de dados

            # Exibir os arquivos GeoTIFF do DSM, RGB e da M√°scara
            st.subheader('Modelo Digital de Superf√≠cie')
            exibir_todas_as_faixas_geotiff(data_layers['dsmUrl'], GOOGLE_SOLAR_KEY, 'Modelo Digital de Superf√≠cie')

            st.subheader('Camada Composta RGB')
            exibir_todas_as_faixas_geotiff(data_layers['rgbUrl'], GOOGLE_SOLAR_KEY, 'Camada Composta RGB')

            st.subheader('M√°scara de Edif√≠cios')
            exibir_todas_as_faixas_geotiff(data_layers['maskUrl'], GOOGLE_SOLAR_KEY, 'M√°scara de Edif√≠cios')

            # Exibir o arquivo GeoTIFF do Fluxo Anual
            st.subheader('Fluxo Anual')
            exibir_todas_as_faixas_geotiff(data_layers['annualFluxUrl'], GOOGLE_SOLAR_KEY, 'Fluxo Anual')

            # Exibir os arquivos GeoTIFF do Fluxo Mensal
            st.subheader('Fluxo Mensal')
            exibir_fluxo_mensal(data_layers, GOOGLE_SOLAR_KEY)

            com st.expander("Clique para expandir a resposta completa da camada de dados", expandido=False):
                st.write(data_layers)

if __name__ == '__main__':
    if check_password():
        main()

