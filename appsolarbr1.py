# -*- coding: utf-8 -*-
"""appsolarbr1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oJzKDi7oakflTfnUDf9Sphl7eXqfjHwM
"""

import streamlit as st
import geocoder
import requests
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from io import BytesIO
from PIL import Image
import rasterio
from rasterio.io import MemoryFile
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import matplotlib.pyplot as plt
import math

# BING_KEY = st.secrets.BING_KEY
GOOGLE_SOLAR_KEY = st.secrets.GOOGLE_SOLAR_KEY
SOLAR_INSIGHTS_ENDPOINT = 'https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude={}&location.longitude={}&requiredQuality=LOW&key={}'

# streamlit_app.py

import streamlit as st

def check_password():
    """Retorna `True` se o usuÃ¡rio inserir a senha correta."""

    def password_entered():
        """Verifica se a senha inserida pelo usuÃ¡rio estÃ¡ correta."""
        if st.session_state["password"] == st.secrets["password"]:
            st.session_state["password_correct"] = True
            del st.session_state["password"]  # nÃ£o armazene a senha
        else:
            st.session_state["password_correct"] = False

    if "password_correct" not in st.session_state:
        # Primeira execuÃ§Ã£o, exibir entrada para a senha.
        st.text_input(
            "Senha", type="password", on_change=password_entered, key="password"
        )
        return False
    elif not st.session_state["password_correct"]:
        # Senha incorreta, exibir entrada + erro.
        st.text_input(
            "Senha", type="password", on_change=password_entered, key="password"
        )
        st.error("ðŸ˜• Senha incorreta")
        return False
    else:
        # Senha correta.
        return True

@st.cache_data
def get_lat_lng_bing(address):
    g = geocoder.bing(address, key=BING_KEY)
    results = g.json
    return (results['lat'], results['lng'])

def get_lat_lng(address):
    """
    ObtÃ©m a latitude e longitude de um endereÃ§o usando a API de GeocodificaÃ§Ã£o do Google.

    ParÃ¢metros:
    - address: O endereÃ§o a ser geocodificado.
    - api_key: Sua chave da API do Google.

    Retorna:
    - Uma tupla contendo a latitude e a longitude.
    """
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={address}&key={GOOGLE_SOLAR_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['status'] == 'OK':
            latitude = data['results'][0]['geometry']['location']['lat']
            longitude = data['results'][0]['geometry']['location']['lng']
            return latitude, longitude
        else:
            print(f"Erro: {data['status']}")
            return None, None
    else:
        print(f"Falha ao obter os dados: {response.status_code}")
        return None, None

@st.cache_data
def get_solar_insights(lat, lng):
    response = requests.get(SOLAR_INSIGHTS_ENDPOINT.format(lat, lng, GOOGLE_SOLAR_KEY))
    return response.json()

@st.cache_data
def get_google_maps_image(lat, lon, zoom=19, size="600x600", maptype="satellite", api_key=GOOGLE_SOLAR_KEY):
    base_url = "https://maps.googleapis.com/maps/api/staticmap?"
    params = {
        "center": f"{lat},{lon}",
        "zoom": zoom,
        "size": size,
        "maptype": maptype,
        "key": api_key
    }
    response = requests.get(base_url, params=params)
    response.raise_for_status()
    image = Image.open(BytesIO(response.content))
    return image

# FunÃ§Ã£o para exibir uma banda especÃ­fica de um arquivo GeoTIFF a partir de uma URL com anotaÃ§Ã£o
def display_monthly_flux(data_layers, api_key):
    # Para o fluxo mensal, vocÃª precisa lidar com vÃ¡rias bandas, pois ele contÃ©m dados para cada mÃªs
    monthly_flux_url_with_key = f"{data_layers['monthlyFluxUrl']}&key={api_key}"
    response = requests.get(monthly_flux_url_with_key)
    if response.status_code == 200:
        with MemoryFile(response.content) as memfile:
            with memfile.open() as dataset:
                for i in range(1, dataset.count + 1):  # Percorrer cada banda
                    fig, ax = plt.subplots()  # Criar uma nova figura e eixos do matplotlib
                    band = dataset.read(i)
                    im = ax.imshow(band) #cmap='viridis')  # Armazenar o objeto mapeÃ¡vel em im
                    #plt.colorbar(im, ax=ax)  # Passar o objeto mapeÃ¡vel para o colorbar
                    ax.set_title(f"Fluxo Solar Mensal - MÃªs {i}")
                    st.pyplot(fig)  # Passar a figura do matplotlib para st.pyplot()
                    plt.close(fig)  # Fechar a figura
    else:
        print(f"Falha ao buscar os dados. CÃ³digo de status: {response.status_code}")
        # FunÃ§Ã£o para exibir todas as bandas de um arquivo GeoTIFF a partir de uma URL com anotaÃ§Ã£o
def display_all_geotiff_bands(url, api_key, title):
    url_with_key = f"{url}&key={api_key}"
    response = requests.get(url_with_key)
    if response.status_code == 200:
        with MemoryFile(response.content) as memfile:
            with memfile.open() as dataset:
                fig, ax = plt.subplots()  # Criar uma nova figura e eixos do matplotlib
                if dataset.count > 1:
                    band = dataset.read([1, 2, 3])
                    band = np.transpose(band, (1, 2, 0))
                else:
                    band = dataset.read(1)
                    band = band.squeeze()

                im = ax.imshow(band)  # Armazenar o objeto mapeÃ¡vel em im, cmap='viridis' se dataset.count == 1 else None
                #plt.colorbar(im, ax=ax)  # Passar o objeto mapeÃ¡vel para o colorbar
                ax.set_title(title)
                st.pyplot(fig)  # Passar a figura do matplotlib para st.pyplot()
                plt.close(fig)  # Fechar a figura

# FunÃ§Ã£o para obter camadas de dados
@st.cache_data
def get_data_layers(lat, lon, radius=50, view="FULL_LAYERS", quality="LOW", pixel_size=0.5):
    url = f"https://solar.googleapis.com/v1/dataLayers:get"
    params = {
        "location.latitude": lat,
        "location.longitude": lon,
        "radiusMeters": radius,
        "view": view,
        "requiredQuality": quality,
        "pixelSizeMeters": pixel_size,
        "key": GOOGLE_SOLAR_KEY  # Substitua pela sua chave real da API Solar do Google
    }
    response = requests.get(url, params=params)
    return response.json()

# VisualizaÃ§Ã£o 2D
def plot_roof_segments(roof_segments):
    # Criar figura e eixos
    fig, ax = plt.subplots()

    # Plotar cada segmento
    for segment in roof_segments:
        sw = segment['boundingBox']['sw']
        ne = segment['boundingBox']['ne']
        center = segment['center']

        # Calcular a largura e a altura do retÃ¢ngulo
        width = ne['longitude'] - sw['longitude']
        height = ne['latitude'] - sw['latitude']

        # Criar um retÃ¢ngulo representando o segmento do telhado
        rect = patches.Rectangle((sw['longitude'], sw['latitude']), width, height,
                                 linewidth=1, edgecolor='r', facecolor='none')
        ax.add_patch(rect)

        # Usar azimute para representar a orientaÃ§Ã£o do segmento do telhado
        azimuth = segment['azimuthDegrees']
        pitch = segment['pitchDegrees']

        # Calcular o ponto final para a linha que indica a orientaÃ§Ã£o
        # Aqui, estamos usando um mÃ©todo simples para calcular o ponto final; vocÃª pode precisar ajustar isso
        end_lon = center['longitude'] + np.cos(np.radians(azimuth)) * width * 0.5
        end_lat = center['latitude'] + np.sin(np.radians(azimuth)) * height * 0.5

        # Desenhar uma linha que indica a orientaÃ§Ã£o do segmento do telhado
        ax.plot([center['longitude'], end_lon], [center['latitude'], end_lat], 'k-')

        # Opcionalmente, anotar o pitch do segmento do telhado
        ax.text(center['longitude'], center['latitude'], f"{pitch:.1f}Â°",
                fontsize=9, ha='center', va='center')

    # Definir rÃ³tulos e tÃ­tulo
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title('Segmentos do Telhado com OrientaÃ§Ã£o e InclinaÃ§Ã£o')

    # Ajustar limites do grÃ¡fico
    ax.set_xlim(min([seg['boundingBox']['sw']['longitude'] for seg in roof_segments]),
                max([seg['boundingBox']['ne']['longitude'] for seg in roof_segments]))
    ax.set_ylim(min([seg['boundingBox']['sw']['latitude'] for seg in roof_segments]),
                max([seg['boundingBox']['ne']['latitude'] for seg in roof_segments]))

    # Mostrar o grÃ¡fico
    st.pyplot(fig)

# VisualizaÃ§Ã£o 3D
def plot_3d_roof_segments(roof_segments):
    if not roof_segments:
        st.write("Nenhum dado de segmentos de telhado disponÃ­vel.")
        return

    fig, ax = plt.subplots(subplot_kw={'projection': '3d'})

    for segment in roof_segments:
        sw = segment['boundingBox']['sw']
        ne = segment['boundingBox']['ne']
        height = segment['planeHeightAtCenterMeters']
        pitch = math.radians(segment['pitchDegrees'])
        azimuth = math.radians(segment['azimuthDegrees'])

        # DepuraÃ§Ã£o: Imprimir inclinaÃ§Ã£o e azimute
        #st.write(f"InclinaÃ§Ã£o: {pitch} radianos, Azimute: {azimuth} radianos")

        # Calcular a diferenÃ§a de altura com base na inclinaÃ§Ã£o e no azimute
        delta_height = np.tan(pitch) * np.sqrt((ne['longitude'] - sw['longitude'])**2 + (ne['latitude'] - sw['latitude'])**2)
        delta_x = delta_height * np.sin(azimuth)
        delta_y = delta_height * np.cos(azimuth)

        vertices = np.array([[sw['longitude'], sw['latitude'], height],
                             [ne['longitude'], sw['latitude'], height + delta_x],
                             [ne['longitude'], ne['latitude'], height + np.sqrt(delta_x**2 + delta_y**2)],
                             [sw['longitude'], ne['latitude'], height + delta_y]])

        # DepuraÃ§Ã£o: Imprimir vÃ©rtices
        #st.write(vertices)

        # Criar faces
        faces = [[vertices[j] for j in [0, 1, 2, 3]]]

        poly = Poly3DCollection(faces, alpha=0.5, edgecolors='k', linewidths=1)
        ax.add_collection3d(poly)

    # Definir limites dos eixos e rÃ³tulos
    ax.set_xlim(min(segment['boundingBox']['sw']['longitude'] for segment in roof_segments),
                max(segment['boundingBox']['ne']['longitude'] for segment in roof_segments))
    ax.set_ylim(min(segment['boundingBox']['sw']['latitude'] for segment in roof_segments),
                max(segment['boundingBox']['ne']['latitude'] for segment in roof_segments))
    ax.set_zlim(0, max(segment['planeHeightAtCenterMeters'] for segment in roof_segments) + 20)  # Limites z ajustados

    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_zlabel('Altura')
    ax.set_title('VisualizaÃ§Ã£o 3D de Segmentos de Telhado')

    # Mostrar grÃ¡fico no Streamlit
    st.pyplot(fig)

# Calculadora
def get_yearly_energy(data, panels_count):
    for config in data['solarPotential']['solarPanelConfigs']:
        if config['panelsCount'] == panels_count:
            return config['yearlyEnergyDcKwh']
    return None

def solar_calculator(data):
    st.subheader('Calculadora de Economia Solar')

    # Extrair nÃºmero mÃ­nimo e mÃ¡ximo de painÃ©is dos resultados da API
    min_panels = data['solarPotential']['solarPanelConfigs'][0]['panelsCount']
    max_panels = data['solarPotential']['maxArrayPanelsCount']

    # Entradas com valores padrÃ£o
    # if 'num_panels' not in st.session_state:
    #     st.session_state.num_panels = max_panels

    if 'kw_per_panel' not in st.session_state:
        st.session_state.kw_per_panel = 0.3

    if 'electricity_price' not in st.session_state:
        st.session_state.electricity_price = 0.12

    if 'panel_area_m2' not in st.session_state:
        st.session_state.panel_area_m2 = 1.5

    # st.session_state.num_panels = st.number_input('NÃºmero de PainÃ©is Solares', value=st.session_state.num_panels)
    # st.session_state.kw_per_panel = st.number_input('kW por Painel Solar', value=st.session_state.kw_per_panel)
    # st.session_state.electricity_price = st.number_input('PreÃ§o da Eletricidade (por kWh)', value=st.session_state.electricity_price)
    # st.session_state.panel_area_m2 = st.number_input('Ãrea por Painel Solar (em m^2)', value=st.session_state.panel_area_m2)

    # CÃ¡lculos
    # Entradas
    panels = st.slider('NÃºmero de PainÃ©is Solares', min_value=min_panels, max_value=max_panels, value=max_panels)
    user_wattage = st.number_input('PotÃªncia do Painel Solar', value=430.0, step=10.0)  # O usuÃ¡rio pode ajustar a potÃªncia
    electricity_price = st.number_input('PreÃ§o da Eletricidade (R$/kWh)', value=0.81, step=0.01)

    # Calcular
    energia_api = get_yearly_energy(data, panels)
    energia_ajustada = energia_api * (user_wattage / 250.0)  # Ajustar com base na potÃªncia especificada pelo usuÃ¡rio
    economia_anual = energia_ajustada * electricity_price

    # Exibir
    st.write(f"GeraÃ§Ã£o Anual de Energia Estimada: {energia_ajustada:.2f} kWh")
    st.write(f"Economia Anual Estimada: R${economia_anual:.2f}")

def main():
    st.title('Insights de PainÃ©is Solares')

    address = st.text_input("Digite seu endereÃ§o:")

    # Verifique se o endereÃ§o estÃ¡ na session_state
    if 'address' not in st.session_state:
        st.session_state.address = ''

    # Verifique se os dados jÃ¡ estÃ£o na session_state e se o endereÃ§o foi alterado
    if 'data' not in st.session_state or st.session_state.address != address:
        if st.button('Obter Insights'):
            lat, lng = get_lat_lng(address)
            data = get_solar_insights(lat, lng)
            print(data)
            st.session_state.data = data
            st.session_state.address = address

    # Se os dados estiverem na session_state, exiba-os
    if 'data' in st.session_state:
        data = st.session_state.data
        lat, lng = get_lat_lng(st.session_state.address)

        # Exibir a imagem da casa
        imagem = get_google_maps_image(lat, lng)
        if 'imageryDate' in data:
            st.image(imagem, caption=f"Imagem da Casa de {data['imageryDate']['year']}-{data['imageryDate']['month']}-{data['imageryDate']['day']}", use_column_width=True)
        else:
            st.image(imagem, caption="Imagem da Casa", use_column_width=True)

        # Exibir dados solares
        st.subheader('Potencial Solar')
        # Adicione uma observaÃ§Ã£o usando st.markdown
        st.markdown("_Aviso: Com base nos dados da API Solar do Google (altura do painel - 1,65m, largura do painel - 0,99m, 250 Watts)._")
        st.markdown(f"_Coordenadas do endereÃ§o: {lat} {lng}_")
        st.write(f"NÃºmero MÃ¡ximo de PainÃ©is na Matriz: {data['solarPotential']['maxArrayPanelsCount']}")
        st.write(f"Ãrea MÃ¡xima de PainÃ©is Solares (m^2): {data['solarPotential']['maxArrayAreaMeters2']}")
        st.write(f"Ãrea Total do Telhado (m^2): {data['solarPotential']['wholeRoofStats']['areaMeters2']}")
        st.write(f"Segmentos de Telhado: {len(data['solarPotential']['roofSegmentStats'])}")
        st.write(f"MÃ¡ximo de Horas de Sol Anuais: {data['solarPotential']['maxSunshineHoursPerYear']}")

        if 'roofSegmentStats' in data['solarPotential']:
            st.subheader('VisualizaÃ§Ã£o 2D de Segmentos de Telhado')
            plot_roof_segments(data['solarPotential']['roofSegmentStats'])

            st.subheader('VisualizaÃ§Ã£o 3D de Segmentos de Telhado')
            segmentos_telhado = data['solarPotential']['roofSegmentStats']
            plot_3d_roof_segments(segmentos_telhado)

        # Calculadora
        solar_calculator(data)

                # expander with full json
        with st.expander("Click to unfold the full solarAPI response", expanded=False):
            st.write(data)

if st.button('Get Data Layers'):
    # Fetch the data layers
    data_layers = get_data_layers(lat, lng)  # Certifique-se de implementar esta funÃ§Ã£o para chamar o segundo API e obter os data layers

    image_urls = {
        'Digital Surface Model': data_layers['dsmUrl'],
        'RGB Composite Layer': data_layers['rgbUrl'],
        'Building Mask': data_layers['maskUrl'],
        'Annual Flux': data_layers['annualFluxUrl'],
    }

    # Create a list to store captions and image URLs
    image_list = list(image_urls.items())

    # Display the images in a gallery
    st.image(image_list, caption=image_list, width=200, use_container_width=True)

    st.subheader('Monthly Flux')
    display_monthly_flux(data_layers, GOOGLE_SOLAR_KEY)

    with st.expander("Click to unfold the full dataLayer response", expanded=False):
        st.write(data_layers)


if __name__ == '__main__':
    if check_password():
        main()

import streamlit as st
import geocoder
import requests
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from io import BytesIO
from PIL import Image
import rasterio
from rasterio.io import MemoryFile
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import matplotlib.pyplot as plt
import math


# BING_KEY = st.secrets.BING_KEY
GOOGLE_SOLAR_KEY = st.secrets.GOOGLE_SOLAR_KEY
SOLAR_INSIGHTS_ENDPOINT = 'https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude={}&location.longitude={}&requiredQuality=LOW&key={}'

# streamlit_app.py

import streamlit as st

def check_password():
    """Returns `True` if the user had the correct password."""

    def password_entered():
        """Checks whether a password entered by the user is correct."""
        if st.session_state["password"] == st.secrets["password"]:
            st.session_state["password_correct"] = True
            del st.session_state["password"]  # don't store password
        else:
            st.session_state["password_correct"] = False

    if "password_correct" not in st.session_state:
        # First run, show input for password.
        st.text_input(
            "Password", type="password", on_change=password_entered, key="password"
        )
        return False
    elif not st.session_state["password_correct"]:
        # Password not correct, show input + error.
        st.text_input(
            "Password", type="password", on_change=password_entered, key="password"
        )
        st.error("ðŸ˜• Password incorrect")
        return False
    else:
        # Password correct.
        return True

@st.cache_data
def get_lat_lng_bing(address):
    g = geocoder.bing(address, key=BING_KEY)
    results = g.json
    return (results['lat'], results['lng'])

def get_lat_lng(address):
    """
    Get the latitude and longitude of a given address using Google Geocoding API.

    Parameters:
    - address: The address to geocode.
    - api_key: Your Google API key.

    Returns:
    - A tuple containing the latitude and longitude.
    """
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={address}&key={GOOGLE_SOLAR_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['status'] == 'OK':
            latitude = data['results'][0]['geometry']['location']['lat']
            longitude = data['results'][0]['geometry']['location']['lng']
            return latitude, longitude
        else:
            print(f"Error: {data['status']}")
            return None, None
    else:
        print(f"Failed to get data: {response.status_code}")
        return None, None

@st.cache_data
def get_solar_insights(lat, lng):
    response = requests.get(SOLAR_INSIGHTS_ENDPOINT.format(lat, lng, GOOGLE_SOLAR_KEY))
    return response.json()

@st.cache_data
def get_google_maps_image(lat, lon, zoom=19, size="600x600", maptype="satellite", api_key=GOOGLE_SOLAR_KEY):
    base_url = "https://maps.googleapis.com/maps/api/staticmap?"
    params = {
        "center": f"{lat},{lon}",
        "zoom": zoom,
        "size": size,
        "maptype": maptype,
        "key": api_key
    }
    response = requests.get(base_url, params=params)
    response.raise_for_status()
    image = Image.open(BytesIO(response.content))
    return image

# Function to display a specific band of a GeoTIFF file from a URL with annotation
def display_monthly_flux(data_layers, api_key):
    # For monthly flux, you need to handle multiple bands as it contains data for each month
    monthly_flux_url_with_key = f"{data_layers['monthlyFluxUrl']}&key={api_key}"
    response = requests.get(monthly_flux_url_with_key)
    if response.status_code == 200:
        with MemoryFile(response.content) as memfile:
            with memfile.open() as dataset:
                for i in range(1, dataset.count + 1):  # Loop through each band
                    fig, ax = plt.subplots()  # Create a new matplotlib figure and axes
                    band = dataset.read(i)
                    im = ax.imshow(band) #cmap='viridis')  # Store the mappable object in im
                    #plt.colorbar(im, ax=ax)  # Pass the mappable object to colorbar
                    ax.set_title(f"Monthly Solar Flux - Month {i}")
                    st.pyplot(fig)  # Pass the matplotlib figure to st.pyplot()
                    plt.close(fig)  # Close the figure
    else:
        print(f"Failed to fetch data. Status code: {response.status_code}")

# Function to display all bands of a GeoTIFF file from a URL with annotation
def display_all_geotiff_bands(url, api_key, title):
    url_with_key = f"{url}&key={api_key}"
    response = requests.get(url_with_key)
    if response.status_code == 200:
        with MemoryFile(response.content) as memfile:
            with memfile.open() as dataset:
                fig, ax = plt.subplots()  # Create a new matplotlib figure and axes
                if dataset.count > 1:
                    band = dataset.read([1, 2, 3])
                    band = np.transpose(band, (1, 2, 0))
                else:
                    band = dataset.read(1)
                    band = band.squeeze()

                im = ax.imshow(band)  # Store the mappable object in im, cmap='viridis' if dataset.count == 1 else None
                #plt.colorbar(im, ax=ax)  # Pass the mappable object to colorbar
                ax.set_title(title)
                st.pyplot(fig)  # Pass the matplotlib figure to st.pyplot()
                plt.close(fig)  # Close the figure

# Function to get data layers
@st.cache_data
def get_data_layers(lat, lon, radius=50, view="FULL_LAYERS", quality="LOW", pixel_size=0.5):
    url = f"https://solar.googleapis.com/v1/dataLayers:get"
    params = {
        "location.latitude": lat,
        "location.longitude": lon,
        "radiusMeters": radius,
        "view": view,
        "requiredQuality": quality,
        "pixelSizeMeters": pixel_size,
        "key": GOOGLE_SOLAR_KEY  # Replace with your actual Google Solar API key
    }
    response = requests.get(url, params=params)
    return response.json()

# 2D visualization
def plot_roof_segments(roof_segments):
    # Create figure and axes
    fig, ax = plt.subplots()

    # Plot each segment
    for segment in roof_segments:
        sw = segment['boundingBox']['sw']
        ne = segment['boundingBox']['ne']
        center = segment['center']

        # Calculate the width and height of the rectangle
        width = ne['longitude'] - sw['longitude']
        height = ne['latitude'] - sw['latitude']

        # Create a rectangle representing the roof segment
        rect = patches.Rectangle((sw['longitude'], sw['latitude']), width, height,
                                 linewidth=1, edgecolor='r', facecolor='none')
        ax.add_patch(rect)

        # Use azimuth to represent the orientation of the roof segment
        azimuth = segment['azimuthDegrees']
        pitch = segment['pitchDegrees']

        # Calculate the endpoint for the line indicating the orientation
        # Here, we're using a simple method to calculate the endpoint; you might need to adjust this
        end_lon = center['longitude'] + np.cos(np.radians(azimuth)) * width * 0.5
        end_lat = center['latitude'] + np.sin(np.radians(azimuth)) * height * 0.5

        # Draw a line indicating the orientation of the roof segment
        ax.plot([center['longitude'], end_lon], [center['latitude'], end_lat], 'k-')

        # Optionally, annotate the pitch of the roof segment
        ax.text(center['longitude'], center['latitude'], f"{pitch:.1f}Â°",
                fontsize=9, ha='center', va='center')

    # Set labels and title
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title('Roof Segments with Orientation and Pitch')

    # Adjust plot limits
    ax.set_xlim(min([seg['boundingBox']['sw']['longitude'] for seg in roof_segments]),
                max([seg['boundingBox']['ne']['longitude'] for seg in roof_segments]))
    ax.set_ylim(min([seg['boundingBox']['sw']['latitude'] for seg in roof_segments]),
                max([seg['boundingBox']['ne']['latitude'] for seg in roof_segments]))

    # Show plot
    st.pyplot(fig)

# 3d visualization
def plot_3d_roof_segments(roof_segments):
    if not roof_segments:
        st.write("No roof segments data available.")
        return

    fig, ax = plt.subplots(subplot_kw={'projection': '3d'})

    for segment in roof_segments:
        sw = segment['boundingBox']['sw']
        ne = segment['boundingBox']['ne']
        height = segment['planeHeightAtCenterMeters']
        pitch = math.radians(segment['pitchDegrees'])
        azimuth = math.radians(segment['azimuthDegrees'])

        # Debugging: Print pitch and azimuth
        #st.write(f"Pitch: {pitch} radians, Azimuth: {azimuth} radians")

        # Calculate the height difference based on pitch and azimuth
        delta_height = np.tan(pitch) * np.sqrt((ne['longitude'] - sw['longitude'])**2 + (ne['latitude'] - sw['latitude'])**2)
        delta_x = delta_height * np.sin(azimuth)
        delta_y = delta_height * np.cos(azimuth)

        vertices = np.array([[sw['longitude'], sw['latitude'], height],
                             [ne['longitude'], sw['latitude'], height + delta_x],
                             [ne['longitude'], ne['latitude'], height + np.sqrt(delta_x**2 + delta_y**2)],
                             [sw['longitude'], ne['latitude'], height + delta_y]])

        # Debugging: Print vertices
        #st.write(vertices)

        # Create faces
        faces = [[vertices[j] for j in [0, 1, 2, 3]]]

        poly = Poly3DCollection(faces, alpha=0.5, edgecolors='k', linewidths=1)
        ax.add_collection3d(poly)

    # Set axes limits and labels
    ax.set_xlim(min(segment['boundingBox']['sw']['longitude'] for segment in roof_segments),
                max(segment['boundingBox']['ne']['longitude'] for segment in roof_segments))
    ax.set_ylim(min(segment['boundingBox']['sw']['latitude'] for segment in roof_segments),
                max(segment['boundingBox']['ne']['latitude'] for segment in roof_segments))
    ax.set_zlim(0, max(segment['planeHeightAtCenterMeters'] for segment in roof_segments) + 20)  # Adjusted z-limits

    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_zlabel('Height')
    ax.set_title('3D Visualization of Roof Segments')

    # Show plot in Streamlit
    st.pyplot(fig)

# calculator
def get_yearly_energy(data, panels_count):
    for config in data['solarPotential']['solarPanelConfigs']:
        if config['panelsCount'] == panels_count:
            return config['yearlyEnergyDcKwh']
    return None

def solar_calculator(data):
    st.subheader('Solar Savings Calculator')

    # Extract min and max panels count from the API results
    min_panels = data['solarPotential']['solarPanelConfigs'][0]['panelsCount']
    max_panels = data['solarPotential']['maxArrayPanelsCount']

    # Input widgets with default values
    #if 'num_panels' not in st.session_state:
     #   st.session_state.num_panels = max_panels

    if 'kw_per_panel' not in st.session_state:
        st.session_state.kw_per_panel = 0.3

    if 'electricity_price' not in st.session_state:
        st.session_state.electricity_price = 0.12

    if 'panel_area_m2' not in st.session_state:
        st.session_state.panel_area_m2 = 1.5

    #st.session_state.num_panels = st.number_input('Number of Solar Panels', value=st.session_state.num_panels)
    #st.session_state.kw_per_panel = st.number_input('kW per Solar Panel', value=st.session_state.kw_per_panel)
    #st.session_state.electricity_price = st.number_input('Price of Electricity (per kWh)', value=st.session_state.electricity_price)
    #st.session_state.panel_area_m2 = st.number_input('Area per Solar Panel (in m^2)', value=st.session_state.panel_area_m2)

    # Calculations
    # Inputs
    panels = st.slider('Number of Solar Panels', min_value=min_panels, max_value=max_panels, value=max_panels)
    user_wattage = st.number_input('Wattage of Solar Panel', value=430.0, step=10.0)  # User can adjust wattage
    electricity_price = st.number_input('Price of Electricity (R$/kWh)', value=0.81, step=0.01)

    # Calculate
    api_energy = get_yearly_energy(data, panels)
    adjusted_energy = api_energy * (user_wattage / 250.0)  # Adjust based on user-specified wattage
    yearly_savings = adjusted_energy * electricity_price

    # Display
    st.write(f"Estimated Yearly Energy Generation: {adjusted_energy:.2f} kWh")
    st.write(f"Estimated Yearly Savings: â‚¬{yearly_savings:.2f}")

def main():
    st.title('Solar Panel Insights')

    address = st.text_input("Enter your address:")

    # Check if the address is in session_state
    if 'address' not in st.session_state:
        st.session_state.address = ''

    # Check if data is already in session_state and if the address has changed
    if 'data' not in st.session_state or st.session_state.address != address:
        if st.button('Get Insights'):
            lat, lng = get_lat_lng(address)
            data = get_solar_insights(lat, lng)
            print(data)
            st.session_state.data = data
            st.session_state.address = address

    # If data is in session_state, display it
    if 'data' in st.session_state:
        data = st.session_state.data
        lat, lng = get_lat_lng(st.session_state.address)

        # Display the image of the house
        image = get_google_maps_image(lat, lng)
        if 'imageryDate' in data:
            st.image(image, caption=f"House Image from {data['imageryDate']['year']}-{data['imageryDate']['month']}-{data['imageryDate']['day']}", use_column_width=True)
        else:
            st.image(image, caption="House Image", use_column_width=True)

        # Display solar data
        st.subheader('Solar Potential')
        # Add a note using st.markdown
        st.markdown("_Disclaimer: Based on Google Solar API data (panel height - 1.65m, panel width - 0.99m, 250 Watts)._")
        st.markdown(f"_Coordinates of the address: {lat} {lng}_")
        st.write(f"Max Array Panels Count: {data['solarPotential']['maxArrayPanelsCount']}")
        st.write(f"Max Solar Panel Area (m^2): {data['solarPotential']['maxArrayAreaMeters2']}")
        st.write(f"Total Roof Area (m^2): {data['solarPotential']['wholeRoofStats']['areaMeters2']}")
        st.write(f"Roof Segments: {len(data['solarPotential']['roofSegmentStats'])}")
        st.write(f"Max Sunshine Hours Per Year: {data['solarPotential']['maxSunshineHoursPerYear']}")

        if 'roofSegmentStats' in data['solarPotential']:
            st.subheader('Roof Segments 2D Visualization')
            plot_roof_segments(data['solarPotential']['roofSegmentStats'])

            st.subheader('Roof Segments 3D Visualization')
            roof_segments = data['solarPotential']['roofSegmentStats']
            plot_3d_roof_segments(roof_segments)

        # Calculator
        solar_calculator(data)

        # expander with full json
        with st.expander("Click to unfold the full solarAPI response", expanded=False):
            st.write(data)

        if st.button('Get Data Layers'):
            # Fetch the data layers
            data_layers = get_data_layers(lat, lng)  # Make sure to implement this function to call the second API and get the data layers

            # Display the DSM, RGB, and Mask GeoTIFF files
            st.subheader('Digital Surface Model')
            display_all_geotiff_bands(data_layers['dsmUrl'], GOOGLE_SOLAR_KEY, 'Digital Surface Model')

            st.subheader('RGB Composite Layer')
            display_all_geotiff_bands(data_layers['rgbUrl'], GOOGLE_SOLAR_KEY, 'RGB Composite Layer')

            st.subheader('Building Mask')
            display_all_geotiff_bands(data_layers['maskUrl'], GOOGLE_SOLAR_KEY, 'Building Mask')

            # Display the Annual Flux GeoTIFF file
            st.subheader('Annual Flux')
            display_all_geotiff_bands(data_layers['annualFluxUrl'], GOOGLE_SOLAR_KEY, 'Annual Flux')

            # Display the Monthly Flux GeoTIFF files
            st.subheader('Monthly Flux')
            display_monthly_flux(data_layers, GOOGLE_SOLAR_KEY)

            with st.expander("Click to unfold the full dataLayer response", expanded=False):
                st.write(data_layers)

if __name__ == '__main__':
    if check_password():
        main()